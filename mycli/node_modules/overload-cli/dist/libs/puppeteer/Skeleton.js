"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const puppeteer_1 = tslib_1.__importDefault(require("puppeteer"));
const utils_1 = require("../../utils");
const { readFileSync } = require('fs');
const { resolve } = require('path');
const MobileRectAttrs = { width: 375, height: 667 };
const BrowserRectAttrs = { width: 1200, height: 1000 };
class Skeleton {
    constructor(options) {
        this.options = options;
    }
    async initialize() {
        this.browser = await puppeteer_1.default.launch({ headless: true });
    }
    async newPage() {
        var _a;
        const page = await ((_a = this.browser) === null || _a === void 0 ? void 0 : _a.newPage());
        if (this.options.isMobile === false) {
            await (page === null || page === void 0 ? void 0 : page.setViewport(Object.assign(Object.assign({}, BrowserRectAttrs), { deviceScaleFactor: 2, isMobile: false })));
        }
        else {
            await (page === null || page === void 0 ? void 0 : page.setViewport(Object.assign(Object.assign({}, MobileRectAttrs), { deviceScaleFactor: 2, isMobile: true })));
        }
        return page;
    }
    async makeSkeleton(page, options) {
        const defer = 5000;
        const scriptContent = await readFileSync(resolve(__dirname, 'skeletonScript.js'), 'utf-8');
        await (page === null || page === void 0 ? void 0 : page.addScriptTag({ content: scriptContent }));
        await (0, utils_1.sleep)(defer);
        const returnData = await (page === null || page === void 0 ? void 0 : page.evaluate(options => {
            return SkeletonScript.genSkeleton(options);
        }, Object.assign({ rootID: this.options.rootID }, options)));
        return returnData;
    }
    async genScreenShot(url, routeConfig) {
        const page = await this.newPage();
        // 设置当前页面的cookie
        if (Array.isArray(routeConfig.cookies)) {
            for (let i = 0; i < routeConfig.cookies.length; i++) {
                await (page === null || page === void 0 ? void 0 : page.setCookie(routeConfig.cookies[i]));
            }
        }
        try {
            await (page === null || page === void 0 ? void 0 : page.goto(url, { waitUntil: 'networkidle2' }));
        }
        catch (error) {
            return { success: false, errorMessage: `以下路径无法访问，请先保证网络畅通 - ${url}` };
        }
        const makeReturnData = await this.makeSkeleton(page, routeConfig);
        if (makeReturnData.success === false) {
            return { success: false, errorMessage: makeReturnData.message };
        }
        let imageFileName = String(new Date().getTime());
        try {
            imageFileName = routeConfig.path.split('/').join('_');
        }
        catch (error) {
            console.error(error);
        }
        imageFileName += '.jpeg';
        let screenshotClip = this.options.isMobile === false ? Object.assign({ x: 0, y: 0 }, BrowserRectAttrs) : Object.assign({ x: 0, y: 0 }, MobileRectAttrs);
        if (routeConfig.clip) {
            screenshotClip = routeConfig.clip;
        }
        await (page === null || page === void 0 ? void 0 : page.screenshot(Object.assign({ type: 'jpeg', path: resolve(utils_1.OutputDirname, imageFileName) }, screenshotClip)));
        let base64Image = await (page === null || page === void 0 ? void 0 : page.screenshot(Object.assign({ type: 'jpeg', encoding: 'base64' }, screenshotClip)));
        base64Image = `data:image/jpg;base64,${base64Image}`;
        return { success: true, data: base64Image };
    }
    async destroy() {
        if (this.browser) {
            await this.browser.close();
            this.browser = undefined;
        }
    }
}
exports.default = Skeleton;
